# 学习笔记

算法题的作业每道题为一个md文件，每道题包含一种或多种解法，每种解法都包含解题思路、代码实现和复杂度分析。


## 第5课  哈希表、映射、集合

### 一、哈希表

哈希表（Hash table），也叫散列表，是根据键值对直接进行访问的数据结构。

具体实现为把键映射到表中一个位置来访问记录，以加快查找速度，映射函数称为哈希函数或散列函数。

如果不同的键经过哈希函数的计算得到的值相同，就产生哈希碰撞。解决方法：在一个地址处存储链表，称为拉链式解决冲突法。如果链表过长，会影响时间复杂度。如果哈希函数设计得好，则平均时间复杂度是O(1)。

哈希表的时间复杂度：查找、插入、删除的平均时间复杂度都是O(1)，最坏情况下的时间复杂度都是O(n)。

哈希表的空间复杂度是O(n)。

### 二、映射

Map：key-value对，key不重复。

常用的具体类有HashMap和TreeMap。

- HashMap的key无序，各项操作的时间复杂度为O(1)。

- TreeMap的key有序，各项操作的时间复杂度为O(log n)。

### 三、集合

Set：不重复元素的集合。

常用的具体类有HashSet和TreeSet。

- HashSet的元素无序，各项操作的时间复杂度为O(1)。

- TreeSet的元素有序，各项操作的时间复杂度为O(log n)。

### 四、作业：关于HashMap的小总结

HashMap的底层数据结构是数组，称为哈希桶，每个桶里放的是链表，链表中的每个节点对应一个元素。

在JDK8中，如果链表长度达到8，会转化成红黑树以提升效率。

链表节点定义为Node<K,V>，实现Map.Entry<K,V>，每个节点包含后续节点，因此是单链表。

增加/更新元素：对应方法put。该方法根据key生成一个hash值，然后调用方法putVal，具体操作如下。

1. 将table赋给tab，并判断tab是否为空或者长度为零，如果是则调用resize方法并更新tab及其长度n。

2. 根据(n - 1) & hash计算i，获得tab的第i个元素。如果为空，则直接插入。

3. 如果不为空，则可能有两种情况。第一种情况是hash值重复，即已经有key对应的value。第二种情况是发生哈希碰撞，则以链表形式存入，或者在链表过长的情况下转换成红黑树。

4. 如果key已经存在，则用value更新键值对，并添加到table中。

查询元素：对应方法get。该方法根据key生成一个hash值，判断是否有对应的value，有则返回value，没有则返回null。该方法调用方法getNode，具体操作如下。

1. 根据(n - 1) & hash判断key是否存在，如果key不存在则返回null。

2. 如果key存在，首先检查第一个节点，如果第一个节点满足要求，直接返回第一个节点。

3. 如果第一个节点不满足要求，则判断是红黑树还是链表，并根据对应的结构查找满足要求的节点并返回。

## 第6课  树、二叉树、二叉搜索树、堆和二叉堆、图

### 一、树

树是二维数据结构。树由节点和边组成，每条边连接两个节点，两个节点之间的关系为父节点和子节点。

树包含一个根节点，位于第0层，其余的节点依次位于第1层、第2层、第3层等。

链表是特殊化的树，树是特殊化的图。

### 二、二叉树

二叉树：每个节点最多有两个子节点，分别为左子节点和右子节点。

二叉树的遍历有三种：前序遍历、中序遍历、后序遍历。

1. 前序遍历：依次访问根节点、左子树、右子树。

2. 中序遍历：依次访问左子树、根节点、右子树。

3. 后序遍历：依次访问左子树、右子树、根节点。

### 三、二叉搜索树

二叉搜索树是一棵空树或者具有下列性质的二叉树：

1. 左子树上所有节点的值均小于根节点的值；

2. 右子树上所有节点的值均大于根节点的值；

3. 左子树和右子树也分别为二叉查找树。

二叉搜索树的中序遍历为升序排列。

二叉搜索树的查询、插入、删除操作的时间复杂度是O(log n)。

### 四、堆和二叉堆

堆是可以迅速找到一堆数种的最大或者最小值的数据结构。常见的有二叉堆和斐波那契堆。

二叉堆的操作的时间复杂度：

- 查找最大/最小元素的时间复杂度是O(1)；

- 删除最大/最小元素的时间复杂度是O(log n)；

- 插入元素的时间复杂度是O(log n)。

二叉堆通过完全二叉树实现。对于大顶堆，根节点的值最大，任意节点的值总是大于或等于其子节点的值；对于最小堆，根节点的值最小，任意节点的值总是小于或等于其子节点的值。

由于二叉堆通过完全二叉树实现，因此二叉堆常用的实现方式是数组。

### 五、图

图：由点和边组成的数据结构。

点的属性包含度，分为入度和出度，以及点与点之间存在是否连通的关系。

边的属性包含有向和无向，以及权重。

图的表示法有两种，邻接矩阵和邻接表。

图的常用算法：广度优先搜索、深度优先搜索。

图的高级算法：连通图个数、拓扑排序、最短路径、最小生成树。
