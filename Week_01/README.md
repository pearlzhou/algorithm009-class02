# 学习笔记

算法题的作业每道题为一个md文件，每道题包含一种或多种解法，每种解法都包含解题思路、代码实现和复杂度分析。

改写Deque代码和分析源码的作业在README的最后。

## 第3课  数组、链表、跳表

### 一、数组

申请数组时，在内存中开辟连续地址。

由于地址连续，可在O(1)时间内查询任何下标的元素。

但是为了维持地址连续的特点，插入和删除元素的时间复杂度较高。

1. 如果在数组末尾插入元素和删除元素，时间复杂度都是O(1)。

2. 如果在数组的其余位置插入元素，则需要首先将从指定位置到末尾的所有元素后移一位，然后在指定位置插入元素，时间复杂度是O(n)，其中n是数组长度。

3. 如果在数组的其余位置删除元素，则在删除元素后，需要将从指定位置后一位到末尾的所有元素前移一位，时间复杂度是O(n)，其中n是数组长度。

具体实现类：ArrayList。

### 二、链表

链表的内存地址不连续，链表中的每个元素是一个节点，每个节点都有相应的值。链表有两种类型。

1. 节点包含指向下一个节点的指针，以这样的节点组成的链表为单向链表。

2. 节点包含指向上一个节点的指针和指向下一个节点的指针，以这样的节点组成的链表为双向链表。

链表中，通常需要指定头节点和尾节点。

在链表中插入和删除元素时，只需要改变相邻节点的指针指向的节点，因此时间复杂度都是O(1)，无论插入和删除的元素是在链表的头部、尾部还是中间。

但是由于链表的内存地址不连续，因此不可像数组那样根据下标直接查询元素，而是需要遍历节点才能查询元素，查询元素的时间复杂度是O(n)，其中n是链表中的元素数量。

具体实现类：LinkedList，为双向链表。

### 三、数组和链表的性能比较

- 数组的查询元素的时间复杂度是O(1)，插入和删除元素的时间复杂度是O(n)。

- 链表的查询元素的时间复杂度是O(n)，插入和删除元素的时间复杂度是O(1)。

基于数组和链表的性能特点，可以得出以下分析。

- 当需要经常查询元素时，使用数组更合适。

- 当需要经常插入和删除元素时，使用链表更合适。

### 四、跳表

跳表的实现基于链表，其目的是降低链表的查询元素的时间复杂度。只适用于元素有序的情况。

跳表对标平衡二叉搜索树和二分查找，插入、删除、查询元素的时间复杂度都是O(log n)，其中n是元素数量。

跳表通过升维的方式进行加速，从一维到二维，包含更多信息。具体实现为在原始链表的基础上增加多级索引，每级索引包含的节点数量依次减少。

跳表的空间复杂度和数组、链表一样是O(n)，但是由于跳表有多级索引，实际使用空间超过数组和链表。

## 第4课  栈、队列、双端队列、优先队列

### 一、栈

Stack：后进先出，添加、删除元素的时间复杂度是O(1)。

由于元素无序，查询的时间复杂度是O(n)，其中n是元素数量。

### 二、队列

Queue：先进先出，添加、删除元素的时间复杂度是O(1)。

由于元素无序，查询的时间复杂度是O(n)，其中n是元素数量。

### 三、双端队列

Deque即Double-Ended Queue：结合了栈和队列的特点，可在头和尾两端添加和删除元素。

双端队列的各项操作的时间复杂度和栈与队列相同，添加、删除元素的时间复杂度是O(1)，查询的时间复杂度是O(n)，其中n是元素数量。

### 四、优先队列

Priority Queue：元素具有优先级顺序，每次取出优先级最高的元素（例如最大值或最小值）。

添加元素的时间复杂度是O(1)，取出元素的时间复杂度是O(log n)，其中n是元素数量。

### 五、API分析

此处只分析Java中的API。

- Stack是具体类，可直接用于实例化对象，但是建议用Deque代替Stack。

- Queue和Deque是接口，需要通过实现类实例化对象，LinkedList是常用的实现类。

- PriorityQueue是Queue的实现类。

